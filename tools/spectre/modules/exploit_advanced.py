#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
EXPLOIT ADVANCED v2.0 - TANQUE EDITION
Exploit chaining Â· Post-exploitation Â· Privilege escalation Â· Persistence
Con detecciÃ³n automÃ¡tica de vectores
"""

import asyncio
import re
from urllib.parse import urlparse, urljoin
from typing import Dict, List, Optional

try:
    from http_client import HTTPClient
except ImportError:
    class HTTPClient:
        async def __aenter__(self): return self
        async def __aexit__(self, *args): pass
        async def get(self, url): return None

class ExploitAdvanced:
    def __init__(self, url: str, aggressive: bool = False):
        self.url = url.rstrip('/')
        self.parsed = urlparse(url)
        self.domain = self.parsed.netloc
        self.aggressive = aggressive
        self.client = None
        self.findings = []
        
        # Post-exploitation paths
        self.post_exploit_paths = [
            '/phpinfo.php', '/info.php', '/.git/config',
            '/.svn/entries', '/.hg/hgrc', '/.bzr/README',
            '/server-status', '/server-info', '/status',
            '/metrics', '/stats', '/debug', '/_profiler',
            '/actuator', '/actuator/health', '/actuator/env',
            '/console', '/h2-console', '/database',
            '/backup', '/backups', '/dump', '/sql',
            '/logs', '/log', '/logging', '/debug.log',
        ]
        
        # Privilege escalation vectors
        self.privesc_paths = [
            '/admin', '/administrator', '/wp-admin', '/manager',
            '/cpanel', '/plesk', '/webmin', '/phpmyadmin',
            '/panel', '/dashboard', '/control', '/console',
            '/root', '/system', '/shell', '/cmd',
            '/exec', '/eval', '/system.php', '/shell.php',
        ]
        
        # Persistence mechanisms
        self.persistence_patterns = [
            (r'ssh-rsa|id_rsa|id_dsa|id_ecdsa', 'SSH key'),
            (r'authorized_keys', 'Authorized keys'),
            (r'cron|anacron|systemd', 'Cron job'),
            (r'startup|rc\.local|init\.d', 'Startup script'),
            (r'bashrc|profile|zshrc|zprofile', 'Shell config'),
            (r'\.service$|\.timer$', 'Systemd service'),
            (r'Task Scheduler|schtasks', 'Windows task'),
            (r'reg add|HKLM|HKCU', 'Registry persistence'),
        ]
        
    async def setup(self):
        """Inicializa cliente HTTP"""
        self.client = HTTPClient(timeout=15, max_retries=2)
        
    async def scan_post_exploit(self) -> List[Dict]:
        """Busca indicadores de post-explotaciÃ³n"""
        findings = []
        
        for path in self.post_exploit_paths:
            url = urljoin(self.url, path)
            try:
                resp = await self.client.get(url)
                
                if resp and resp.status == 200:
                    text = await resp.text()
                    
                    # PHP info
                    if 'phpinfo' in path:
                        if 'PHP Version' in text:
                            findings.append({
                                'type': 'PHPINFO_EXPOSED',
                                'url': url,
                                'severity': 'ALTO'
                            })
                            print(f"   [[WARN]] PHP info expuesto: {url}")
                            
                    # Git config
                    elif '.git' in path:
                        if 'repositoryformatversion' in text:
                            findings.append({
                                'type': 'GIT_EXPOSED',
                                'url': url,
                                'severity': 'CRITICO'
                            })
                            print(f"   [[CRITICO]] Repositorio git expuesto: {url}")
                            
                    # Server status
                    elif 'server-status' in path:
                        if 'Server Version' in text or 'Apache' in text:
                            findings.append({
                                'type': 'SERVER_STATUS',
                                'url': url,
                                'severity': 'MEDIO'
                            })
                            print(f"   [[INFO]] Server status: {url}")
                            
                    # Actuator
                    elif 'actuator' in path:
                        findings.append({
                            'type': 'ACTUATOR_EXPOSED',
                            'url': url,
                            'severity': 'ALTO'
                        })
                        print(f"   [[WARN]] Actuator endpoint: {url}")
                        
            except:
                pass
                
        return findings
        
    async def scan_privesc(self) -> List[Dict]:
        """Busca vectores de escalada"""
        findings = []
        
        for path in self.privesc_paths:
            url = urljoin(self.url, path)
            try:
                resp = await self.client.get(url)
                
                if resp and resp.status != 404:
                    findings.append({
                        'type': 'PRIVESC_VECTOR',
                        'url': url,
                        'status': resp.status,
                        'severity': 'MEDIO'
                    })
                    
                    if resp.status == 200:
                        print(f"   [[INFO]] Posible vector privesc: {url}")
                    elif resp.status in [401, 403]:
                        print(f"   [[LOCK]] Panel protegido: {url}")
                        
            except:
                pass
                
        return findings
        
    async def detect_persistence(self) -> List[Dict]:
        """Detecta mecanismos de persistencia"""
        findings = []
        
        # Archivos comunes
        persistence_files = [
            '/.ssh/authorized_keys',
            '/etc/crontab',
            '/etc/systemd/system/',
            '/etc/rc.local',
            '/etc/profile',
            '/.bashrc',
            '/.zshrc',
            '/boot.ini',
            '/windows/system32/drivers/etc/hosts',
        ]
        
        for path in persistence_files:
            url = urljoin(self.url, path)
            try:
                resp = await self.client.get(url)
                
                if resp and resp.status == 200:
                    text = await resp.text()
                    
                    for pattern, ptype in self.persistence_patterns:
                        if re.search(pattern, text, re.IGNORECASE):
                            findings.append({
                                'type': 'PERSISTENCE_MECHANISM',
                                'url': url,
                                'pattern': ptype,
                                'severity': 'CRITICO'
                            })
                            print(f"   [[CRITICO]] Persistencia detectada: {ptype} en {url}")
                            break
                            
            except:
                pass
                
        return findings
        
    async def test_exploit_chaining(self, vulnerabilities: List[Dict]) -> List[Dict]:
        """Analiza posibles cadenas de exploits"""
        findings = []
        
        if len(vulnerabilities) < 2:
            return findings
            
        vuln_types = [v.get('type', '') for v in vulnerabilities]
        
        # SSRF + Git = cÃ³digo fuente
        if 'GIT_EXPOSED' in vuln_types and any('SSRF' in v for v in vuln_types):
            findings.append({
                'type': 'EXPLOIT_CHAIN',
                'chain': ['SSRF', 'GIT_EXPOSED'],
                'description': 'SSRF puede leer archivos git del servidor',
                'severity': 'CRITICO'
            })
            print(f"   [[CRITICO]] Cadena: SSRF + Git")
            
        # PHP info + LFI = RCE
        if 'PHPINFO_EXPOSED' in vuln_types and any('LFI' in v for v in vuln_types):
            findings.append({
                'type': 'EXPLOIT_CHAIN',
                'chain': ['PHPINFO', 'LFI'],
                'description': 'PHPinfo + LFI puede llevar a RCE',
                'severity': 'CRITICO'
            })
            
        return findings
        
    async def scan(self):
        """Ejecuta anÃ¡lisis completo"""
        print(f"\nðŸ’€ EXPLOIT ADVANCED v2.0 TANQUE - {self.url}")
        print("=" * 70)
        
        await self.setup()
        all_vulns = []
        
        try:
            # Post-explotaciÃ³n
            print("[*] Buscando indicadores de post-explotaciÃ³n...")
            findings = await self.scan_post_exploit()
            self.findings.extend(findings)
            all_vulns.extend(findings)
            
            # Escalada de privilegios
            print("\n[*] Buscando vectores de escalada...")
            findings = await self.scan_privesc()
            self.findings.extend(findings)
            all_vulns.extend(findings)
            
            # Persistencia
            print("\n[*] Detectando mecanismos de persistencia...")
            findings = await self.detect_persistence()
            self.findings.extend(findings)
            all_vulns.extend(findings)
            
            # Exploit chaining
            print("\n[*] Analizando cadenas de exploits...")
            findings = await self.test_exploit_chaining(all_vulns)
            self.findings.extend(findings)
            
            # Resumen
            print("\n" + "="*70)
            print("ðŸ“Š RESULTADOS EXPLOTACIÃ“N AVANZADA")
            print("="*70)
            
            if self.findings:
                criticos = [f for f in self.findings if f['severity'] == 'CRITICO']
                altos = [f for f in self.findings if f['severity'] == 'ALTO']
                
                if criticos:
                    print(f"\n[CRITICO] CRÃTICOS: {len(criticos)}")
                    for f in criticos:
                        print(f"   â€¢ {f['type']}: {f.get('url', f.get('description', ''))}")
                        
                if altos:
                    print(f"\n[WARN]  ALTOS: {len(altos)}")
                    
                print(f"\n[OK] TOTAL: {len(self.findings)}")
            else:
                print("\n[OK] No se encontraron vectores de explotaciÃ³n avanzada")
                
        finally:
            if self.client:
                await self.client.close()
                
        return self.findings

async def main():
    if len(sys.argv) < 2:
        print("Uso: python3 exploit_advanced.py <URL> [--aggressive]")
        sys.exit(1)
        
    url = sys.argv[1]
    aggressive = '--aggressive' in sys.argv
    
    scanner = ExploitAdvanced(url, aggressive)
    await scanner.scan()

if __name__ == "__main__":
    asyncio.run(main())
