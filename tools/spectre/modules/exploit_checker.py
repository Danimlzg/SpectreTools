#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
EXPLOIT CHECKER v4.0 - Zero-Day Hunter Edition
Integraci√≥n con Searchsploit + Detecci√≥n proactiva de zero-days
Analiza respuestas de otros m√≥dulos para identificar comportamientos zero-day
"""

import asyncio
import subprocess
import json
import re
import os
import sys
from typing import Dict, List, Optional, Tuple, Any
from datetime import datetime, timedelta
import aiohttp
try:
    from .http_client import get_session, DEFAULT_HEADERS, TIMEOUT
except ImportError:
    from http_client import get_session, DEFAULT_HEADERS, TIMEOUT

class ExploitChecker:
    def __init__(self, technologies: Dict, versions: Dict, libraries: List = None, other_findings: Dict = None):
        """
        technologies: dict con tecnolog√≠as detectadas
        versions: dict con versiones encontradas
        libraries: lista de librer√≠as con versiones
        other_findings: hallazgos de otros m√≥dulos (sqli, xss, ssrf, etc.)
        """
        self.technologies = technologies
        self.versions = versions
        self.libraries = libraries or []
        self.other_findings = other_findings or {}
        self.findings = []
        self.session = None
        self.zero_day_candidates = []

        # Cache de resultados
        self.cache = {}
        self.cve_cache = {}

        # === PATRONES ZERO-DAY AMPLIADOS ===
        self.zero_day_patterns = {
            'memory_corruption': [
                r'segmentation fault',
                r'buffer overflow',
                r'stack smashing',
                r'heap corruption',
                r'use after free',
                r'double free',
                r'null pointer dereference',
                r'out-of-bounds',
                r'type confusion',
                r'race condition',
                r'assertion.*failed',
                r'terminate called after throwing',
                r'pure virtual method called',
                r'bad allocation',
                r'access violation',
                r'memory access violation',
            ],
            'memory_exhaustion': [
                r'memory leak',
                r'out of memory',
                r'cannot allocate memory',
                r'alloc failed',
                r'malloc failure',
                r'new failed',
                r'allocation failed',
                r'memory exhausted',
                r'failed to allocate',
                r'unable to allocate',
            ],
            'crash_indicators': [
                r'Exception in thread',
                r'Fatal error',
                r'Internal error',
                r'Server Error',
                r'Application Error',
                r'Uncaught Exception',
                r'Unhandled Exception',
                r'Stack trace',
                r'core dumped',
                r'ERROR:',
                r'CRITICAL:',
                r'PANIC:',
                r'Kernel panic',
                r'System crash',
            ],
            'info_disclosure': [
                r'stack trace',
                r'debug info',
                r'full path:',
                r'absolute path:',
                r'document root:',
                r'physical path:',
                r'Server variable',
                r'phpinfo\(\)',
                r'getenv\(',
                r'$_SERVER',
                r'$_ENV',
                r'apache_getenv',
                r'print_r\(',
                r'var_dump\(',
                r'debug_print_backtrace',
            ],
            'injection_errors': [
                r'sql syntax error',
                r'ODBC Driver',
                r'Unclosed quotation mark',
                r'Warning: mysql_',
                r'pg_query\(\)',
                r'sqlite_fetch',
                r'Unsanitized input',
                r'command injection',
                r'execution failed',
                r'system\(\)',
                r'passthru\(\)',
                r'shell_exec\(\)',
            ],
            'weird_behaviors': [
                r'infinite loop',
                r'deadlock',
                r'timeout',
                r'too many connections',
                r'connection reset',
                r'broken pipe',
                r'protocol error',
                r'invalid state',
                r'corrupted data',
                r'malformed request',
            ]
        }

        # === FIRMAS DE COMPORTAMIENTO ZERO-DAY ===
        self.zero_day_signatures = [
            {
                'name': 'Possible Heap Spray',
                'pattern': r'(%0a|%0d|%00).{100,}(%0a|%0d|%00)',
                'severity': 'ALTO'
            },
            {
                'name': 'ROP Chain Attempt',
                'pattern': r'0x[0-9a-f]{8,16}.*0x[0-9a-f]{8,16}.*0x[0-9a-f]{8,16}',
                'severity': 'CRITICO'
            },
            {
                'name': 'Shellcode Pattern',
                'pattern': r'(\\x[0-9a-f]{2}){20,}',
                'severity': 'CRITICO'
            },
            {
                'name': 'Format String Attack',
                'pattern': r'(%[0-9]*\$[xXsp]){3,}',
                'severity': 'ALTO'
            },
            {
                'name': 'JOP Gadget Chain',
                'pattern': r'jmp.*esp.*call.*eax.*push.*ret',
                'severity': 'CRITICO'
            }
        ]

        # Scoring weights para priorizaci√≥n
        self.score_weights = {
            'rce': 10.0,
            'privesc': 9.5,
            'sqli': 9.0,
            'lfi': 8.5,
            'rfi': 8.5,
            'file_upload': 8.0,
            'xss': 6.0,
            'csrf': 5.0,
            'dos': 5.0,
            'info': 3.0
        }

    async def __aenter__(self):
        self.session = await get_session()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()

    def check_searchsploit_installed(self) -> Tuple[bool, str]:
        """Verifica si searchsploit est√° instalado y su ruta"""
        try:
            possible_paths = [
                '/usr/bin/searchsploit',
                '/usr/local/bin/searchsploit',
                '/opt/exploitdb/searchsploit',
                'searchsploit'
            ]
            
            for path in possible_paths:
                result = subprocess.run(['which', path], capture_output=True, text=True)
                if result.returncode == 0:
                    return True, result.stdout.strip()
            
            return False, "No encontrado"
        except:
            return False, "Error en verificaci√≥n"

    def check_metasploit_installed(self) -> bool:
        """Verifica si Metasploit est√° instalado"""
        try:
            msf_paths = [
                '/usr/share/metasploit-framework/',
                '/opt/metasploit/',
                '/usr/local/share/metasploit-framework/'
            ]
            for path in msf_paths:
                if os.path.exists(path):
                    return True
            return False
        except:
            return False

    async def search_searchsploit(self, software: str, version: str = None) -> List[Dict]:
        """Busca exploits en searchsploit (versi√≥n exacta o difusa)"""
        results = []

        # Crear clave para cach√©
        cache_key = f"{software}_{version if version else 'any'}"
        if cache_key in self.cache:
            return self.cache[cache_key]

        try:
            # Preparar t√©rmino de b√∫squeda
            if version and version != 'desconocida' and version != '.' and len(version) < 20:
                search_terms = [
                    f"{software} {version}",
                    f"{software}-{version}",
                    f"{software}_{version}"
                ]
            else:
                search_terms = [software]

            for term in search_terms:
                cmd = ['searchsploit', '--json', term]
                
                process = await asyncio.create_subprocess_exec(
                    *cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                stdout, stderr = await process.communicate()

                if stdout:
                    try:
                        data = json.loads(stdout)
                        for exploit in data.get('RESULTS_EXPLOIT', []):
                            title = exploit.get('Title', '')
                            
                            # Verificar relevancia
                            if version and version != 'desconocida':
                                if version not in title and version.replace('.', '') not in title:
                                    continue

                            edb_id = exploit.get('EDB-ID', '')
                            
                            # Obtener CVE asociado
                            cve = await self.get_cve_from_edb(edb_id)
                            
                            # Calcular score
                            exploit_type = self.classify_exploit(title)
                            score = self.calculate_exploit_score({
                                'title': title,
                                'type': exploit_type,
                                'date': exploit.get('Date', ''),
                                'cve': cve,
                                'edb_id': edb_id
                            })

                            # Verificar si est√° en Metasploit
                            in_metasploit = await self.check_in_metasploit(edb_id) if self.check_metasploit_installed() else False

                            results.append({
                                'edb_id': edb_id,
                                'title': title,
                                'type': exploit_type,
                                'url': f"https://www.exploit-db.com/exploits/{edb_id}",
                                'author': exploit.get('Author', ''),
                                'date': exploit.get('Date', ''),
                                'platform': exploit.get('Platform', ''),
                                'verified': True,
                                'is_zero_day': False,
                                'cve': cve,
                                'score': score,
                                'in_metasploit': in_metasploit
                            })
                    except json.JSONDecodeError:
                        # Fallback a parsing manual
                        if stdout:
                            lines = stdout.decode().split('\n')
                            for line in lines:
                                if 'EDB-ID' in line or software.lower() in line.lower():
                                    edb_match = re.search(r'EDB-ID: (\d+)', line)
                                    if edb_match:
                                        edb_id = edb_match.group(1)
                                        results.append({
                                            'edb_id': edb_id,
                                            'title': line.strip(),
                                            'type': 'UNKNOWN',
                                            'url': f"https://www.exploit-db.com/exploits/{edb_id}",
                                            'verified': False,
                                            'is_zero_day': False,
                                            'score': 5.0
                                        })

                # Si encontramos resultados, no seguir buscando
                if results:
                    break

        except Exception as e:
            print(f"   [*] Error en searchsploit para {software} {version}: {e}")

        # Guardar en cach√©
        self.cache[cache_key] = results
        return results

    async def get_cve_from_edb(self, edb_id: str) -> Optional[str]:
        """Obtiene el CVE asociado a un EDB-ID usando cach√©"""
        if edb_id in self.cve_cache:
            return self.cve_cache[edb_id]

        try:
            url = f"https://www.exploit-db.com/exploits/{edb_id}"
            async with self.session.get(url, timeout=10) as resp:
                if resp.status == 200:
                    html = await resp.text()
                    cve_match = re.search(r'CVE-\d{4}-\d{4,7}', html)
                    if cve_match:
                        cve = cve_match.group(0)
                        self.cve_cache[edb_id] = cve
                        return cve
        except:
            pass
        
        self.cve_cache[edb_id] = None
        return None

    async def check_in_metasploit(self, edb_id: str) -> bool:
        """Verifica si el exploit est√° en Metasploit Framework"""
        try:
            msf_paths = [
                '/usr/share/metasploit-framework/modules/',
                '/opt/metasploit-framework/modules/',
                '/usr/local/share/metasploit-framework/modules/'
            ]
            
            for base_path in msf_paths:
                if os.path.exists(base_path):
                    cmd = ['grep', '-r', edb_id, base_path]
                    process = await asyncio.create_subprocess_exec(
                        *cmd,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.DEVNULL
                    )
                    stdout, _ = await process.communicate()
                    if stdout:
                        return True
            return False
        except:
            return False

    def calculate_exploit_score(self, exploit: Dict) -> float:
        """Calcula score de 0-10 basado en relevancia y peligrosidad"""
        score = 5.0  # Base
        
        title = exploit.get('title', '').lower()
        exploit_type = exploit.get('type', 'UNKNOWN')
        
        # + puntos por tipo de exploit
        type_weight = self.score_weights.get(exploit_type.lower(), 3.0)
        score += (type_weight - 5.0)
        
        # + puntos por exploits recientes
        if exploit.get('date'):
            try:
                date_str = exploit['date']
                if isinstance(date_str, str):
                    date = datetime.strptime(date_str[:10], '%Y-%m-%d')
                    days_old = (datetime.now() - date).days
                    if days_old < 30:
                        score += 1.5
                    elif days_old < 90:
                        score += 0.75
                    elif days_old < 365:
                        score += 0.25
            except:
                pass
        
        # +0.5 por tener CVE
        if exploit.get('cve'):
            score += 0.5
        
        # +0.5 por estar en Metasploit
        if exploit.get('in_metasploit'):
            score += 0.5
        
        return max(0.0, min(10.0, score))

    async def analyze_other_findings(self) -> List[Dict]:
        """Analiza hallazgos de otros m√≥dulos en busca de zero-days"""
        zero_day_findings = []

        if not self.other_findings:
            return zero_day_findings

        print("\n   [*] Analizando hallazgos de otros m√≥dulos en busca de zero-days...")

        # Analizar SQLi findings
        sqli_findings = self.other_findings.get('sqli', [])
        for finding in sqli_findings:
            if finding.get('severity') == 'CRITICO':
                # Si hay SQLi cr√≠tico pero no hay exploit conocido, es zero-day candidate
                zero_day_findings.append({
                    'type': 'ZERO_DAY_CANDIDATE',
                    'source': 'sqli_advanced',
                    'description': f"SQL injection cr√≠tica sin exploit conocido",
                    'details': finding,
                    'severity': 'CRITICO',
                    'is_zero_day': True
                })

        # Analizar XSS findings
        xss_findings = self.other_findings.get('xss', [])
        for finding in xss_findings:
            if finding.get('type') == 'DOM_XSS_SINK':
                # DOM XSS en sinks peligrosos podr√≠a ser zero-day
                zero_day_findings.append({
                    'type': 'ZERO_DAY_CANDIDATE',
                    'source': 'xss_advanced',
                    'description': f"DOM XSS sink inusual - posible zero-day",
                    'details': finding,
                    'severity': 'ALTO',
                    'is_zero_day': True
                })

        # Analizar SSRF findings
        ssrf_findings = self.other_findings.get('ssrf', [])
        for finding in ssrf_findings:
            if finding.get('blind'):
                # Blind SSRF dif√≠cil de detectar, posible zero-day
                zero_day_findings.append({
                    'type': 'ZERO_DAY_CANDIDATE',
                    'source': 'ssrf_tester',
                    'description': f"Blind SSRF detectado - posible zero-day",
                    'details': finding,
                    'severity': 'CRITICO',
                    'is_zero_day': True
                })

        # Analizar Command Injection findings
        cmd_findings = self.other_findings.get('command_injection', [])
        for finding in cmd_findings:
            # Command injection siempre es cr√≠tico
            zero_day_findings.append({
                'type': 'ZERO_DAY_CANDIDATE',
                'source': 'sqli_advanced',
                'description': f"Command injection sin exploit p√∫blico",
                'details': finding,
                'severity': 'CRITICO',
                'is_zero_day': True
            })

        return zero_day_findings

    async def check_zero_day_patterns(self, content: str, source: str) -> List[Dict]:
        """Analiza contenido en busca de patrones de zero-day"""
        findings = []

        # Patrones generales
        for category, patterns in self.zero_day_patterns.items():
            for pattern in patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                if matches:
                    findings.append({
                        'type': 'ZERO_DAY_PATTERN',
                        'category': category,
                        'pattern': pattern,
                        'source': source,
                        'severity': 'CRITICO' if category in ['memory_corruption', 'crash_indicators'] else 'ALTO',
                        'is_zero_day': True
                    })

        # Firmas espec√≠ficas de zero-day
        for signature in self.zero_day_signatures:
            if re.search(signature['pattern'], content, re.IGNORECASE):
                findings.append({
                    'type': 'ZERO_DAY_SIGNATURE',
                    'name': signature['name'],
                    'source': source,
                    'severity': signature['severity'],
                    'is_zero_day': True
                })

        return findings

    async def check_recent_cves(self, software: str, version: str = None) -> List[Dict]:
        """Consulta NVD para CVEs recientes (posibles zero-days)"""
        results = []

        try:
            if version and version != 'desconocida':
                keyword = f"{software} {version}"
            else:
                keyword = software

            url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
            params = {
                'keywordSearch': keyword,
                'resultsPerPage': 50,
                'startIndex': 0
            }

            async with self.session.get(url, params=params, timeout=15) as resp:
                if resp.status == 200:
                    data = await resp.json()
                    for vuln in data.get('vulnerabilities', []):
                        cve = vuln.get('cve', {})
                        published = cve.get('published', '')
                        
                        if published:
                            try:
                                pub_date = datetime.fromisoformat(published.replace('Z', '+00:00'))
                                days_old = (datetime.now() - pub_date).days
                                
                                # CVEs de los √∫ltimos 90 d√≠as = posibles zero-days
                                if days_old < 90:
                                    metrics = cve.get('metrics', {})
                                    cvss_v3 = metrics.get('cvssMetricV31', [{}])[0].get('cvssData', {})
                                    cvss_score = cvss_v3.get('baseScore', 'N/A')
                                    
                                    severity = 'CRITICO'
                                    if cvss_score != 'N/A':
                                        if float(cvss_score) >= 9.0:
                                            severity = 'CRITICO'
                                        elif float(cvss_score) >= 7.0:
                                            severity = 'ALTO'
                                        elif float(cvss_score) >= 4.0:
                                            severity = 'MEDIO'
                                    
                                    results.append({
                                        'edb_id': cve.get('id', ''),
                                        'title': cve.get('descriptions', [{}])[0].get('value', ''),
                                        'type': 'CVE',
                                        'url': f"https://nvd.nist.gov/vuln/detail/{cve.get('id', '')}",
                                        'date': published,
                                        'cvss_score': cvss_score,
                                        'verified': True,
                                        'is_zero_day': True,
                                        'severity': severity,
                                        'days_old': days_old
                                    })
                            except:
                                pass
        except Exception as e:
            print(f"   [*] Error consultando NVD: {e}")
        
        return results

    def classify_exploit(self, title: str) -> str:
        """Clasifica el tipo de exploit por su t√≠tulo"""
        title_lower = title.lower()

        if any(x in title_lower for x in ['rce', 'remote code execution', 'code execution', 'command injection']):
            return 'RCE'
        elif any(x in title_lower for x in ['privilege escalation', 'privesc', 'root', 'admin bypass']):
            return 'PRIVESC'
        elif any(x in title_lower for x in ['sql', 'sql injection', 'sqli']):
            return 'SQLi'
        elif 'lfi' in title_lower or 'local file inclusion' in title_lower:
            return 'LFI'
        elif 'rfi' in title_lower or 'remote file inclusion' in title_lower:
            return 'RFI'
        elif any(x in title_lower for x in ['upload', 'file upload']):
            return 'FILE_UPLOAD'
        elif any(x in title_lower for x in ['xss', 'cross site scripting']):
            return 'XSS'
        elif any(x in title_lower for x in ['csrf', 'cross site request forgery']):
            return 'CSRF'
        elif any(x in title_lower for x in ['dos', 'denial of service']):
            return 'DoS'
        elif any(x in title_lower for x in ['buffer overflow', 'stack overflow']):
            return 'BOF'
        elif any(x in title_lower for x in ['information disclosure', 'path disclosure']):
            return 'INFO_DISCLOSURE'
        elif any(x in title_lower for x in ['bypass', 'authentication bypass']):
            return 'AUTH_BYPASS'
        else:
            return 'UNKNOWN'

    def get_severity_from_score(self, score: float, is_zero_day: bool = False) -> str:
        """Determina la severidad basada en el score"""
        if is_zero_day:
            return 'CRITICO'
        
        if score >= 8.0:
            return 'CRITICO'
        elif score >= 6.0:
            return 'ALTO'
        elif score >= 4.0:
            return 'MEDIO'
        elif score >= 2.0:
            return 'BAJO'
        else:
            return 'INFO'

    def format_exploit_output(self, exploit: Dict) -> str:
        """Formatea la salida de un exploit para consola"""
        output = []
        
        type_emoji = {
            'RCE': 'üíÄ',
            'PRIVESC': 'üëë',
            'SQLi': '[SQLi]',
            'LFI': 'üìÇ',
            'RFI': '[WEB]',
            'FILE_UPLOAD': 'üì§',
            'XSS': '[XSS]',
            'CSRF': 'üîÑ',
            'DoS': 'üí•',
            'BOF': 'üì¶',
            'INFO_DISCLOSURE': 'üîç',
            'AUTH_BYPASS': 'üîë',
            'CVE': 'üìã',
            'ZERO_DAY_PATTERN': '[CRITICO][CRITICO]',
            'ZERO_DAY_SIGNATURE': '[CRITICO][CRITICO]',
            'ZERO_DAY_CANDIDATE': '[CRITICO][CRITICO]',
            'UNKNOWN': '‚ùì'
        }
        
        emoji = type_emoji.get(exploit.get('type', 'UNKNOWN'), '‚Ä¢')
        
        main_line = f"   [{emoji}] {exploit.get('title', '')[:100]}"
        if len(exploit.get('title', '')) > 100:
            main_line += '...'
        output.append(main_line)
        
        details = []
        if exploit.get('edb_id'):
            details.append(f"EDB-ID: {exploit['edb_id']}")
        if exploit.get('cve'):
            details.append(f"CVE: {exploit['cve']}")
        if exploit.get('type'):
            details.append(f"Tipo: {exploit['type']}")
        if exploit.get('score'):
            details.append(f"Score: {exploit['score']:.1f}/10")
        if exploit.get('in_metasploit'):
            details.append("[OK] En Metasploit")
        if exploit.get('cvss_score') and exploit['cvss_score'] != 'N/A':
            details.append(f"CVSS: {exploit['cvss_score']}")
        if exploit.get('source'):
            details.append(f"Fuente: {exploit['source']}")
        if exploit.get('category'):
            details.append(f"Categor√≠a: {exploit['category']}")
        
        if details:
            output.append(f"        ‚Ü≥ {' | '.join(details)}")
        
        if exploit.get('url'):
            output.append(f"        ‚Ü≥ {exploit['url']}")
        
        return '\n'.join(output)

    async def scan(self):
        """Ejecuta la b√∫squeda de exploits y zero-days"""
        print(f"\nüí• EXPLOIT CHECKER v4.0 - Zero-Day Hunter Edition")
        print("=" * 70)

        # Verificar instalaciones
        has_searchsploit, ss_path = self.check_searchsploit_installed()
        has_metasploit = self.check_metasploit_installed()
        
        if has_searchsploit:
            print(f"[‚úì] Searchsploit detectado: {ss_path}")
        else:
            print("[!] Searchsploit no instalado")
        
        if has_metasploit:
            print("[‚úì] Metasploit detectado")
        
        print("-" * 70)

        # Inicializar sesi√≥n HTTP
        async with self:

            # 1. Analizar hallazgos de otros m√≥dulos (zero-day candidates)
            zero_day_candidates = await self.analyze_other_findings()
            for zd in zero_day_candidates:
                self.findings.append({
                    'software': 'multiple',
                    'version': 'unknown',
                    'exploit': zd,
                    'severity': zd['severity'],
                    'source': zd['source'],
                    'is_zero_day': True
                })
                print(f"\n[CRITICO][CRITICO] POSIBLE ZERO-DAY DETECTADO:")
                print(f"   ‚Ä¢ {zd['description']}")
                print(f"     ‚Ü≥ Fuente: {zd['source']} | Severidad: {zd['severity']}")

            # 2. Buscar exploits para tecnolog√≠as principales
            for tech, version in self.versions.items():
                if version and version != 'desconocida' and version != '.' and len(str(version)) < 20:
                    print(f"\n[*] Analizando {tech} {version}...")

                    # Exploits conocidos
                    if has_searchsploit:
                        exploits = await self.search_searchsploit(tech, version)
                    else:
                        exploits = []

                    for exploit in exploits:
                        severity = self.get_severity_from_score(exploit.get('score', 5.0), exploit.get('is_zero_day', False))
                        self.findings.append({
                            'software': tech,
                            'version': version,
                            'exploit': exploit,
                            'severity': severity,
                            'source': 'searchsploit' if has_searchsploit else 'local_db'
                        })
                        print(self.format_exploit_output(exploit))

                    # Zero-day: buscar CVEs recientes
                    print(f"\n   [*] Buscando CVEs recientes para {tech} {version}...")
                    zero_days = await self.check_recent_cves(tech, version)
                    for zd in zero_days:
                        self.findings.append({
                            'software': tech,
                            'version': version,
                            'exploit': zd,
                            'severity': zd.get('severity', 'CRITICO'),
                            'source': 'nvd'
                        })
                        print(self.format_exploit_output(zd))

            # 3. Buscar exploits para librer√≠as
            for lib in self.libraries:
                if isinstance(lib, dict):
                    lib_name = lib.get('libreria', '') or lib.get('name', '')
                    lib_version = lib.get('version', '')
                    
                    if (lib_name and lib_version and 
                        lib_version != 'desconocida' and 
                        lib_version != '.' and 
                        len(str(lib_version)) < 20):
                        
                        print(f"\n[*] Analizando librer√≠a {lib_name} {lib_version}...")

                        if has_searchsploit:
                            exploits = await self.search_searchsploit(lib_name, lib_version)
                        else:
                            exploits = []

                        for exploit in exploits:
                            severity = self.get_severity_from_score(exploit.get('score', 5.0), exploit.get('is_zero_day', False))
                            self.findings.append({
                                'software': lib_name,
                                'version': lib_version,
                                'exploit': exploit,
                                'severity': severity,
                                'source': 'searchsploit' if has_searchsploit else 'local_db',
                                'type': 'libreria'
                            })
                            print(self.format_exploit_output(exploit))

        # Mostrar resultados finales
        self.print_summary()
        return self.findings

    def print_summary(self):
        """Muestra resumen de findings"""
        print("\n" + "="*70)
        print("üìä EXPLOITS Y ZERO-DAYS ENCONTRADOS")
        print("="*70)

        if self.findings:
            # Clasificar findings
            zero_days = [f for f in self.findings if f.get('exploit', {}).get('is_zero_day', False) or f.get('is_zero_day', False)]
            criticos = [f for f in self.findings if f['severity'] == 'CRITICO' and f not in zero_days]
            altos = [f for f in self.findings if f['severity'] == 'ALTO' and f not in zero_days]
            
            # Exploits en Metasploit
            metasploit = [f for f in self.findings if f.get('exploit', {}).get('in_metasploit')]

            # Zero-days
            if zero_days:
                print(f"\n[CRITICO][CRITICO] ZERO-DAYS DETECTADOS ({len(zero_days)}):")
                for f in zero_days:
                    exp = f.get('exploit', {})
                    if exp:
                        print(f"   ‚Ä¢ {f['software']} {f['version']}")
                        print(f"     ‚Ü≥ {exp.get('title', '')[:100]}")
                        if exp.get('cvss_score'):
                            print(f"     ‚Ü≥ CVSS: {exp['cvss_score']} | Publicado: {exp.get('date', '')[:10]}")
                        elif exp.get('description'):
                            print(f"     ‚Ü≥ {exp.get('description', '')[:100]}")
                    else:
                        print(f"   ‚Ä¢ {exp.get('description', 'Zero-day candidate')}")

            # Exploits cr√≠ticos
            if criticos:
                print(f"\nüíÄ EXPLOITS CR√çTICOS ({len(criticos)}):")
                for f in sorted(criticos, key=lambda x: x.get('exploit', {}).get('score', 0), reverse=True)[:5]:
                    exp = f['exploit']
                    print(f"   ‚Ä¢ {f['software']} {f['version']}")
                    print(f"     ‚Ü≥ {exp.get('title', '')[:100]}")
                    print(f"     ‚Ü≥ EDB-ID: {exp.get('edb_id', 'N/A')} | Tipo: {exp['type']} | Score: {exp.get('score', 0):.1f}/10")

            # Exploits de alto riesgo
            if altos:
                print(f"\n[WARN]  EXPLOITS DE ALTO RIESGO ({len(altos)}):")
                for f in altos[:5]:
                    exp = f['exploit']
                    print(f"   ‚Ä¢ {f['software']} {f['version']} - {exp.get('title', '')[:80]}")

            # Exploits en Metasploit
            if metasploit:
                print(f"\n[XSS] EXPLOITS EN METASPLOIT ({len(metasploit)}):")
                for f in metasploit[:5]:
                    exp = f['exploit']
                    print(f"   ‚Ä¢ {f['software']} {f['version']} - EDB-ID: {exp.get('edb_id', 'N/A')}")

            # Totales
            print(f"\n[OK] TOTAL: {len(self.findings)}")
            print(f"   [CRITICO] Zero-days: {len(zero_days)}")
            print(f"   üíÄ Cr√≠ticos: {len(criticos)}")
            print(f"   [WARN]  Altos: {len(altos)}")
            print(f"   [XSS] En Metasploit: {len(metasploit)}")

        else:
            print("\n   [OK] No se encontraron exploits p√∫blicos para las versiones detectadas")
            print("   (Esto puede ser bueno: significa que las versiones est√°n actualizadas)")

async def main():
    """Ejemplo de uso para pruebas"""
    versions = {
        'wordpress': '6.4.3',
        'apache': '2.4.29',
        'github-enterprise': '3.19.1'
    }
    libraries = [
        {'libreria': 'jQuery', 'version': '3.7.1'},
        {'libreria': 'Vue.js', 'version': '3.4.0'}
    ]
    
    # Simular hallazgos de otros m√≥dulos
    other_findings = {
        'sqli': [{'severity': 'CRITICO', 'type': 'SQLI', 'param': 'id'}],
        'xss': [{'type': 'DOM_XSS_SINK', 'url': '/js/app.js'}],
        'command_injection': [{'param': 'cmd', 'payload': '; ls'}]
    }

    checker = ExploitChecker([], versions, libraries, other_findings)
    await checker.scan()

if __name__ == "__main__":
    asyncio.run(main())
